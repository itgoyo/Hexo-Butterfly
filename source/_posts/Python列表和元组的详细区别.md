---
title: Python列表和元组的详细区别
category: Python
author: itgoyo
tags: Python
toc: true
date: 2019-09-27 09:43:57
keywords:
description:
source_url:
---

Python 列表和元组的详细区别
一、列表和元组的区别
列表是动态数组，它们不可变且可以重设长度（改变其内部元素的个数）。
元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。
元组缓存于 Python 运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。
这些区别结实率两者在设计哲学上的不同：

列表可被用于保存多个互相独立对象的数据集合
元组用于描述一个不会改不安的事务的多个属性
二、列表（List）
列表一旦创建了我们就可以根据自己的需要随意改变它的内容：
```language


>>> l = [1, 2, 3, 4, 5, 6]
>>> l[0] = l[2] * l[3]
>>> l
[12, 2, 3, 4, 5, 6]
```

另外我们可以给列边添加新的数据来增加其大小：
```
>>> len(l)
6
>>> l.append(7)
>>> l
[12, 2, 3, 4, 5, 6, 7]
>>> len(l)
7
```
这是因为动态数组支持 resize 操作，可以增加数组的容量。当一个大小为 N 的列表第一次需要添加数据时，Python 会创建一个新的列表，足够放原来的 N 个元素以及额外添加的元素。不过，实际分配的并不是 N+1 个元素，而是 M 个元素，M > N, 这是为了给未来的添加预留空间。然后旧列表的数据被复制到新列表中，旧列表则会被销毁。从设计理念上来说，第一次添加可能是后续多次添加的开始，通过预留空间的做法，我们就可以减少这一分配空间的操作次数以及内存复制的次数。这点非常重要，因为内存复制可能非常的昂贵，特别是当列表大小开始增长以后。



三、元组（Tuple）
元组是固定且不可改变的。这意味着一旦元组被创建，和列表不同，它的内容无法被修改或它的大小也无法被改变。
```
>>> t = (1, 2, 3, 4)
>>> t[0] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```
虽然它们不支持改变大小，但是我们可以将两个元组合并成一个新元组。这一操作类似列表的 resize 操作，但我们不需要为新生的元组分配任何额外的空间：
```
>>> t1 = (1, 2, 3, 4)
>>> t2 = (5, 6, 7, 8)
>>> t1 + t2
(1, 2, 3, 4, 5, 6, 7, 8)
```
如果我们将其与列表的 append 操作比较，我们会看到它的复杂度是 O (n) 而不是列表的 O (1)。这是因为对元组每添加一个新元素都会有分配和复制操作，而不是像列表那样仅在额外的空间耗尽时发生。所以元组并没有提供一个类似 append 的自增操作，任意两个元组相加始终返回一个新分配的元组。

该网站为 Python Tutor, 一个能够对 python 运行内存可视化的网站，非常适合初学者研究，在运行过程中内存发生了什么。

元组的静态特性的另一个好处体现在一些会在 Python 后台发生的事情：资源缓存。

Python 是一门垃圾收集语言，这意味着当一个变量不再被使用时，Python 会将该变量使用的内存释放回操作系统，以供其他程序（变量）使用。然而，对于长度为 1~20 的元组，即使它们不在被使用，它们的空间也不会立刻还给系统，而是留待未来使用。这意味着当未来需要一个同样大小的新的元组时，我们不再需要向操作系统申请一块内存来存放数据，因为我们已经有了预留的空间。

这看上去可能是个细微的好处，但是实际上是元组一个很神奇的地方：它们可以被轻松快速地创建，因为它们可以避免跟操作系统频繁的打交道，而后者会花很长的时间。

下面举个例子会非常直观的说明问题
```
In [1]: %timeit l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
93.7 ns ± 3.33 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [2]: %timeit t = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
18.5 ns ± 1.19 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
```
上面的示例中显示了初始化一个列表比初始化一个元组慢了 5.1 倍 —— 如果这是在一个循环中，这点差别会很快的累加起来。





---

<div align=center>
发现更多更好玩的，欢迎关注我的微信公众号:fullstacker

![](/img/qrcode.jpg)
</div>
